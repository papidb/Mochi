# Mochi

Mochi is a p2p service like Abeg.

This app is a production-ready Node.js app. The app comes with many built-in features, such as authentication using JWT,

---

For more details, check the features list below.

## Quick Start

```bash
git clone --depth 1 https://github.com/benjamin-daniel/Mochi
cd Mochi
yarn init
```

### API Endpoints

List of available routes:

**Auth routes**:\
`POST /users/signup` - register\
`POST /users/login` - login\

**Transactions routes**:\
`POST /transactions` - get users transaction\
`GET /transactions/transfer` - transfer to user\

## Table of Contents

- [Mochi](#mochi)
  - [Quick Start](#quick-start)
    - [API Endpoints](#api-endpoints)
  - [Table of Contents](#table-of-contents)
  - [Features](#features)
  - [Environment Variables](#environment-variables)
  - [Project Structure](#project-structure)
  - [Authentication](#authentication)
  - [Logging](#logging)

## Features

- **MySql database**: [MongoDB](https://www.mysql.com) object data modeling using [Knex](http://knexjs.org)
- **Authentication and authorization**: using [passport](http://www.passportjs.org)
- **Logging**: using [winston](https://github.com/winstonjs/winston) and [morgan](https://github.com/expressjs/morgan)
- **Error handling**: centralized error handling mechanism
- **Process management**: advanced production process management using [PM2](https://pm2.keymetrics.io)
- **Dependency management**: with [Yarn](https://yarnpkg.com)
- **Environment variables**: using [dotenv](https://github.com/motdotla/dotenv)
- **CORS**: Cross-Origin Resource-Sharing enabled using [cors](https://github.com/expressjs/cors)
- **Linting**: with [ESLint](https://eslint.org) and [Prettier](https://prettier.io)

## Environment Variables

The environment variables can be found and modified in the `.env` file. They come with these default values:

```bash
# Debug
LOG_LEVEL='debug'

# Port
PORT=3434

# db
DB_NAME=mochi_dev
DB_USERNAME=root
DB_PASSWORD=omowegodeyalright

# mailgun
MAILGUN_API_KEY=lskdsdlksd
MAILGUN_DOMAIN=https://api.mailgun.net/v3/sdklsdlk.mailgun.org



JWT_SECRET=mayflower
JWT_ACCESS_EXPIRATION_MINUTES=60
JWT_REFRESH_EXPIRATION_DAYS=10
JWT_RESET_PASSWORD_EXPIRATION_MINUTES=60

SECRET_KEY_PAYSTACK=sk
PUBLIC_KEY_PAYSTACK=pk
```

## Project Structure

```
src\
 |--config\         # Environment variables and configuration related things
 |--loaders\        # Dependency variable
 |--helpers\        # Helper files
 |--middlewares\    # Custom express middlewares
 |--models\         # Knex models (data layer)
 |--api\            # Contains api routes
 |--services\       # Business logic (service layer)
 |--utils\          # Utility classes and functions
 |--app.js          # App entry Point
```

## Authentication

To require authentication for certain routes, you can use the `auth` middleware.

```javascript
const express = require('express');
const auth = require('../../middlewares/auth');
const userController = require('../../controllers/user.controller');

const router = express.Router();

router.post('/users', auth(), userController.createUser);
```

These routes require a valid JWT access token in the Authorization request header using the Bearer schema. If the request does not contain a valid access token, an Unauthorized (401) error is thrown.

**Generating Access Tokens**:

An access token can be generated by making a successful call to the register (`POST /auth/register`) or login (`POST /auth/login`) endpoints. The response of these endpoints also contains refresh tokens (explained below).

An access token is valid for 30 minutes. You can modify this expiration time by changing the `JWT_ACCESS_EXPIRATION_MINUTES` environment variable in the .env file.

**Refreshing Access Tokens**:

TODO: refresh the token(ü§¶üèΩ‚Äç‚ôÇÔ∏è)
After the access token expires, a new access token can be generated, by making a call to the refresh token endpoint (`POST /auth/refresh-tokens`) and sending along a valid refresh token in the request body. This call returns a new access token and a new refresh token.

A refresh token is valid for 30 days. You can modify this expiration time by changing the `JWT_REFRESH_EXPIRATION_DAYS` environment variable in the .env file.

## Logging

Import the logger from `src/loaders/logger.js`. It is using the [Winston](https://github.com/winstonjs/winston) logging library.

Logging should be done according to the following severity levels (ascending order from most important to least important):

```javascript
const logger = require('<path to src>/loaders/logger');

logger.error('message'); // level 0
logger.warn('message'); // level 1
logger.info('message'); // level 2
logger.http('message'); // level 3
logger.verbose('message'); // level 4
logger.debug('message'); // level 5
```

In development mode, log messages of all severity levels will be printed to the console.

In production mode, only `info`, `warn`, and `error` logs will be printed to the console.\
It is up to the server (or process manager) to actually read them from the console and store them in log files.\
This app uses pm2 in production mode, which is already configured to store the logs in log files.

Note: API request information (request url, response code, timestamp, etc.) are also automatically logged (using [morgan](https://github.com/expressjs/morgan)).
